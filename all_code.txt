
# main.py
import time
import carla
import signal

from carla_interface import CarlaInterface
from road_follower import RoadFollower
from obstacle_spawner import ObstacleSpawner
from bspline_planner import BSplinePlanner
from path_follower import PathFollower
from radar_processor import RadarProcessor
from decision import DecisionEngine
from controller import Controller

def main():
    print("Starting ver.RADAR")
    
    # Create instances
    interface = CarlaInterface()
    processor = RadarProcessor()
    decision_module = DecisionEngine()
    controller = Controller()
    
    running = True
    mode = "NORMAL"  # NORMAL | AVOID | RETURN

    def signal_handler(sig, frame):
        nonlocal running
        running = False

    signal.signal(signal.SIGINT, signal_handler)

    try:
        # Connect
        interface.setup_world()
        
        # Spawn ego and lead
        # Spawn ego and lead
        interface.spawn_ego_vehicle()
        spawner = ObstacleSpawner(interface.world, interface.ego_vehicle)
        planner = BSplinePlanner()
        follower = PathFollower(interface.ego_vehicle)
        road_follower = RoadFollower(interface.world, interface.ego_vehicle)
        avoiding = False
        # traffic = TrafficSpawner(interface.world, interface.ego_vehicle) (Disabled TM)
        # interface.spawn_lead_vehicle() (Using ObstacleSpawner instead?)
        
        # Setup radar
        interface.attach_sensors()
        
        print("System Initialized.")

        # Loop
        while running:
            # Tick world manually (as per interface assumption of sync mode)
            interface.world.tick()
            spawner.tick()
            # traffic.tick()
            
            # Read radar data
            radar_data = interface.get_radar_data()
            
            if radar_data:
                # Get (dist, rel_vel)
                result = processor.process_radar_data(radar_data)
                dist, rel_vel = result
                
                # Print them
                print(f"Dist: {dist}, RelVel: {rel_vel}")
                
                # CALL DECISION MODULE
                state, ttc = decision_module.decide(dist, 0.0)

                # --- STATE MACHINE ---

                if follower.has_path():
                    follower.tick()

                    if mode == "AVOID":
                        if dist > 30.0:
                            print("âœ… Obstacle passed, starting return")
                            mode = "RETURN"

                            ego_loc = interface.ego_vehicle.get_location()
                            ego_wp = interface.world.get_map().get_waypoint(ego_loc)
                            next_wp = ego_wp.next(60.0)[0]

                            path = planner.generate_path(ego_loc, next_wp.transform.location, offset=0.0)
                            follower.set_path(path)

                    elif mode == "RETURN":
                        pass  # Let path finish

                else:
                    # No active path

                    if mode == "RETURN":
                        print("âœ… Return complete")
                        mode = "NORMAL"

                    if mode == "NORMAL":
                        if dist < 22.0:
                            print("ðŸš¨ Starting avoidance maneuver")

                            ego_loc = interface.ego_vehicle.get_location()
                            ego_wp = interface.world.get_map().get_waypoint(ego_loc)
                            next_wp = ego_wp.next(80.0)[0]

                            path = planner.generate_path(ego_loc, next_wp.transform.location, offset=5.5)
                            follower.set_path(path)

                            mode = "AVOID"

                        else:
                            # Normal road following
                            control = controller.get_control(state, ttc)
                            steer = road_follower.get_steer()
                            control.steer = steer
                            interface.ego_vehicle.apply_control(control)

                interface.update_spectator()
            
            time.sleep(0.05)
            
    except Exception as e:
        print(f"Error: {e}")
    finally:
        print("Cleaning up...")
        if 'spawner' in locals():
            spawner.cleanup()
            
        interface.cleanup()

if __name__ == "__main__":
    main()


# carla_interface.py
import carla
import queue
import config
import math
import random


class CarlaInterface:
    def __init__(self):
        self.client = None
        self.world = None
        self.ego_vehicle = None
        self.lead_vehicle = None
        self.radar_sensor = None
        self.radar_queue = queue.Queue()
        self.actors = []

    def setup_world(self):
        self.client = carla.Client(config.HOST, config.PORT)
        self.client.set_timeout(config.TIMEOUT)
        self.world = self.client.get_world()
        
        # Setup settings
        settings = self.world.get_settings()
        settings.synchronous_mode = False   # IMPORTANT
        settings.fixed_delta_seconds = None
        self.world.apply_settings(settings)

    def spawn_ego_vehicle(self):
        blueprint_library = self.world.get_blueprint_library()
        bp = blueprint_library.filter(config.EGO_VEHICLE_FILTER)[0]

        spawn_points = self.world.get_map().get_spawn_points()
        spawn_point = random.choice(spawn_points)

        self.ego_vehicle = self.world.try_spawn_actor(bp, spawn_point)

        if self.ego_vehicle is None:
            raise RuntimeError("Failed to spawn ego vehicle on road")

        print(f"Ego Vehicle spawned: {self.ego_vehicle.type_id}")
        self.actors.append(self.ego_vehicle)
        self.update_spectator()

    def spawn_lead_vehicle(self, distance=25.0):
        blueprint_library = self.world.get_blueprint_library()
        vehicle_bp = blueprint_library.filter(config.LEAD_VEHICLE_FILTER)[0]

        ego_transform = self.ego_vehicle.get_transform()
        ego_wp = self.world.get_map().get_waypoint(ego_transform.location)

        next_wps = ego_wp.next(distance)
        target_wp = next_wps[0]

        spawn_transform = target_wp.transform
        spawn_transform.location.z += 0.5

        self.lead_vehicle = self.world.try_spawn_actor(vehicle_bp, spawn_transform)

        if self.lead_vehicle is None:
            print("âŒ Failed to spawn lead vehicle")
            return None

        print("âœ… Lead vehicle spawned")

        self.actors.append(self.lead_vehicle)
        return self.lead_vehicle

    def attach_sensors(self):
        blueprint_library = self.world.get_blueprint_library()
        radar_bp = blueprint_library.find('sensor.other.radar')
        
        radar_bp.set_attribute('horizontal_fov', '30')
        radar_bp.set_attribute('vertical_fov', '10')
        radar_bp.set_attribute('range', str(config.RADAR_RANGE))
        radar_bp.set_attribute('points_per_second', str(config.RADAR_POINTS_PER_SECOND))
        radar_bp.set_attribute('sensor_tick', str(0.0)) # Capture as fast as possible (or match tick)

        # Mount at x=2.0, z=1.0
        transform = carla.Transform(carla.Location(x=2.0, z=1.0))
        
        self.radar_sensor = self.world.spawn_actor(radar_bp, transform, attach_to=self.ego_vehicle)
        self.radar_sensor.listen(self.radar_queue.put)

    def get_radar_data(self):
        try:
            return self.radar_queue.get(block=False)
        except queue.Empty:
            return None


    def update_spectator(self):
        if self.ego_vehicle and self.world:
            spectator = self.world.get_spectator()
            ego_trans = self.ego_vehicle.get_transform()
            
            # Calculate position behind and above ego
            yaw = math.radians(ego_trans.rotation.yaw)
            # Offset: -10m (behind), +5m (up)
            x = ego_trans.location.x - 10 * math.cos(yaw)
            y = ego_trans.location.y - 10 * math.sin(yaw)
            z = ego_trans.location.z + 5.0
            
            loc = carla.Location(x=x, y=y, z=z)
            rot = carla.Rotation(pitch=-20, yaw=ego_trans.rotation.yaw, roll=0)
            
            spectator.set_transform(carla.Transform(loc, rot))

    def cleanup(self):
        if self.radar_sensor:
            self.radar_sensor.destroy()
        
        for actor in self.actors:
            if actor.is_alive:
                actor.destroy()
        self.actors = []
            
        if self.world:
            settings = self.world.get_settings()
            settings.synchronous_mode = False
            self.world.apply_settings(settings)


# obstacle_spawner.py
import carla
import random
import time

class ObstacleSpawner:
    def __init__(self, world, ego_vehicle):
        self.world = world
        self.ego = ego_vehicle
        self.last_spawn = time.time()
        self.spawn_interval = 10.0
        self.actors = []

    def tick(self):
        if time.time() - self.last_spawn < self.spawn_interval:
            return

        self.last_spawn = time.time()

        bp_lib = self.world.get_blueprint_library()
        vehicle_bp = random.choice(bp_lib.filter("vehicle.*"))

        ego_wp = self.world.get_map().get_waypoint(self.ego.get_location())
        next_wps = ego_wp.next(random.uniform(20, 40))

        if not next_wps:
            return

        wp = random.choice(next_wps)
        transform = wp.transform
        transform.location.z += 0.5

        vehicle = self.world.try_spawn_actor(vehicle_bp, transform)
        if vehicle:
            print("âœ… Spawned obstacle vehicle")
            self.actors.append(vehicle)

    def cleanup(self):
        for a in self.actors:
            if a.is_alive:
                a.destroy()


# bspline_planner.py
import numpy as np
from scipy.interpolate import splprep, splev
import math
import carla

class BSplinePlanner:
    def generate_path(self, current, target, offset=6.0):
        # Align to road, not target
        import carla
        client = carla.Client("localhost", 2000)
        world = client.get_world()
        m = world.get_map()
        ego_wp = m.get_waypoint(current)
        yaw = math.radians(ego_wp.transform.rotation.yaw)
        
        c = math.cos(yaw)
        s = math.sin(yaw)
        
        # Helper to rotation
        def rotate_point(lx, ly):
            # Rotate local point (lx, ly) by yaw and add to current
            wx = current.x + (lx * c - ly * s)
            wy = current.y + (lx * s + ly * c)
            return carla.Location(x=wx, y=wy, z=current.z)
            
        # P0: Current
        p0 = current
        
        # P1: Forward 15m
        p1 = rotate_point(15.0, 0.0)
        
        # P2: Forward 35m, Side offset
        p2 = rotate_point(35.0, offset)
        
        # P3: Forward 70m, Side offset
        p3 = rotate_point(70.0, offset)
        
        points = [p0, p1, p2, p3]
        return self._bspline(points)

    def _bspline(self, points):
        x = [p.x for p in points]
        y = [p.y for p in points]
        
        # If we have duplicate points, splprep might fail, but with 12m spacing it's fine.
        pts = np.vstack([x, y])
        
        try:
            # k=3 needs 4 points. We have 4.
            tck, _ = splprep(pts, k=3, s=0.0)
        except:
            # Fallback to k=2 if something weird happens (though 4 pts is enough for k=3 cubic)
            tck, _ = splprep(pts, k=2, s=0.0)
            
        u = np.linspace(0, 1, 30)
        out = splev(u, tck)
        
        return list(zip(out[0], out[1]))


# path_follower.py
import carla
import math

class PathFollower:
    def __init__(self, vehicle):
        self.vehicle = vehicle
        self.path = []
        self.index = 0
        self.lookahead = 6.0
        self.last_progress = None
        self.stuck_counter = 0

    def set_path(self, path):
        self.path = path
        self.index = 0
        self.last_progress = None
        self.stuck_counter = 0

    def has_path(self):
        return self.path is not None and self.index < len(self.path)

    def tick(self):
        if not self.has_path():
            return

        loc = self.vehicle.get_location()


        # Find target > lookahead
        while self.index < len(self.path):
            wp_loc = carla.Location(x=self.path[self.index][0], y=self.path[self.index][1]) # Assuming tuple (x,y)
            if loc.distance(wp_loc) > self.lookahead:
                target = self.path[self.index]
                break
            self.index += 1

        if self.index >= len(self.path):
            self.path = None
            return

        target = self.path[self.index]
        dx = target[0] - loc.x
        dy = target[1] - loc.y

        yaw = math.radians(self.vehicle.get_transform().rotation.yaw)
        angle = math.atan2(dy, dx)
        steer = math.atan2(math.sin(angle - yaw), math.cos(angle - yaw))

        while steer > math.pi: steer -= 2 * math.pi
        while steer < -math.pi: steer += 2 * math.pi

        # Clamp steering
        steer = max(-0.6, min(0.6, steer))

        control = carla.VehicleControl()
        control.throttle = 0.45
        control.steer = steer
        control.brake = 0.0

        self.vehicle.apply_control(control)


# road_follower.py
import carla
import math

class RoadFollower:
    def __init__(self, world, vehicle):
        self.world = world
        self.vehicle = vehicle

    def step(self, target_speed=8.0):
        transform = self.vehicle.get_transform()
        location = transform.location

        wp = self.world.get_map().get_waypoint(location)
        next_wp = wp.next(5.0)[0]

        target = next_wp.transform.location
        yaw = math.radians(transform.rotation.yaw)

        dx = target.x - location.x
        dy = target.y - location.y

        angle = math.atan2(dy, dx)
        steer = (angle - yaw)
        steer = max(-1.0, min(1.0, steer))

        control = carla.VehicleControl()
        control.throttle = 0.4
        control.steer = steer
        control.brake = 0.0

        self.vehicle.apply_control(control)

    def get_steer(self):
        transform = self.vehicle.get_transform()
        location = transform.location

        wp = self.world.get_map().get_waypoint(location)
        next_wp = wp.next(5.0)[0]

        target = next_wp.transform.location
        yaw = math.radians(transform.rotation.yaw)

        dx = target.x - location.x
        dy = target.y - location.y

        angle = math.atan2(dy, dx)
        steer = (angle - yaw)
        steer = max(-1.0, min(1.0, steer))
        return steer


# radar_processor.py
import math

class RadarProcessor:
    def __init__(self):
        self.last_dist = float("inf")

    def process_radar_data(self, radar_data):
        min_dist = float("inf")
        rel_vel = 0.0

        for det in radar_data:
            az = det.azimuth
            alt = det.altitude
            depth = det.depth

            x = depth * math.cos(alt) * math.cos(az)

            if x > 0 and depth < min_dist:
                min_dist = depth
                rel_vel = det.velocity

        if min_dist == float("inf"):
            return float("inf"), 0.0

        # Exponential smoothing
        if self.last_dist == float("inf"):
             self.last_dist = min_dist

        alpha = 0.4
        min_dist = alpha * min_dist + (1 - alpha) * self.last_dist
        self.last_dist = min_dist

        return min_dist, rel_vel


# decision.py
import config

class DecisionEngine:
    def __init__(self):
        self.current_state = "NORMAL"

    def decide(self, distance, relative_velocity):
        """
        Decides the state based on distance and relative velocity.
        """
        if distance is None or relative_velocity is None:
            self.current_state = "NORMAL"
            ttc = float('inf')
            print(f"State: {self.current_state}, Dist: None, TTC: inf")
            return self.current_state, ttc

        # Compute closing speed
        closing_speed = max(-relative_velocity, 0.1)
        
        ttc = distance / closing_speed
        
        # State Machine Logic
        if distance < 8.0:
            self.current_state = "EMERGENCY"
        elif distance < 15.0:
            self.current_state = "BRAKE"
        else:
            self.current_state = "NORMAL"
            
        print(f"State: {self.current_state}, Dist: {distance:.2f}, TTC: {ttc:.2f}")
        
        return self.current_state, ttc


# controller.py
import carla


class Controller:
    def __init__(self):
        pass

    def get_control(self, state, ttc):
        """
        Generates control signal based on state.
        
        Args:
            state: decision.State
            ttc: float (Time To Collision)
            
        Returns:
            carla.VehicleControl
        """
        control = carla.VehicleControl()

        # DO NOT TOUCH control.steer !!!

        if state == "EMERGENCY":
            control.throttle = 0.0
            control.brake = 1.0
        elif state == "BRAKE":
            control.throttle = 0.0
            control.brake = min(1.0, max(0.2, 3.0 / max(ttc, 0.1)))
        elif state == "NORMAL":
            control.throttle = 0.4
            control.brake = 0.0
            
        return control


# config.py
# System Configuration

# CARLA Server
HOST = "localhost"
PORT = 2000
TIMEOUT = 5.0

# Simulation Settings
SYNC_MODE = True
FIXED_DELTA_SECONDS = 0.05  # 20 Hz
TM_PORT = 8000

# Actors
EGO_VEHICLE_FILTER = 'vehicle.tesla.model3'
LEAD_VEHICLE_FILTER = 'vehicle.nissan.patrol'

# Radar Settings
RADAR_RANGE = 80.0
RADAR_FOV_AZIMUTH = 10.0
RADAR_FOV_ELEVATION = 10.0
RADAR_POINTS_PER_SECOND = 1500
RADAR_FREQUENCY = 20.0
RADAR_AZIMUTH_THRESHOLD = 5.0

# Control & Decision
TARGET_SPEED_KMH = 30.0
SAFE_DISTANCE = 8.0

# State Machine Thresholds
EMERGENCY_TTC = 1.2
BRAKE_TTC = 3.0
